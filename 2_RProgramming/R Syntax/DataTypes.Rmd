---
title: "R_programming_DataStructures"
author: "Frank Fichtenmueller"
date: "31 October 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

$\pagebreak$

## R Working with basic data structures in R

In R there are basic data types:

* **Datatypes**
    * character
    * numeric (real number)
    * integer
    * complex
    * logical / boolean (TRUE/FALSE)  


```{r}
x <- c(1,3,4,5,6)
class(x)


# Numeric
x

# The logical 
as.logical(x)
class(as.logical(x))

# The charcter
as.character(x)
class(as.character(x))

# The complex number
as.complex(x)
class(as.complex(x))

# 

```

There are different datastructures to hold combinations of these datatypes.

* **Datatypes**
    * The vector 
    * The matrix
    * The list
    * The Factor Levels


## Lets look at the basic vector first

It can only **hold ony type of data** and will therefore find coerce the data, to find a common minimum representation. 
As this is done automatically, it can lead to problems if not taken into account.

```{r}

# It can hold only a specific type of data, so conversion happens under the hood
l <- c('a', 1, 4+0i, TRUE)
l

# Its class is set to be able to accompany all given inputs
class(l)
class(l[4])

# It can be indexed, therefore it remembers position 
l[1]
l[1:3]


#The following mixes can occur
y <- c(1.7, 'a') #Character
y <- c(TRUE, 2)  #numeric
y <- c(1, 5+0i)  #complex 

```

### Attributes

Datatypes carry **5 basic kind** of attributes that sets them appart and influences their specific behaviour. 

* names, dimnames
* dimensions (matrices, arrays)
* class (e.g. integer, numeric, etc..)
* length
* other user-defined attributes/metadata

These can be accessed using the `attributes()` function call. If the R object does not contain attributes the function call will 
return `NULL`.

Even though an object might not return `attributes`, we can still use the following functions to adress attributes directly.

* `dim()` will return the dimensions of the object (Null for Vector)
* `length()` returns the number of entries in the object


```{r}
x
attributes(x)
length(x)
dim(x)

```


### Matrices

Matrices are vectors with a dimension attribute. The dimension is itself an integer vector of length 2(number of rows, number of columns)

```{r}
m <- matrix(nrow=2, ncol=3)
dim(m)
attributes(m)
```

They are constructed column wise by combing single column vectors along the n-row dimension. Given a `vector of length n` they will split it
according to the `nrow` attribute.

```{r}
matrix(1:6, nrow=3, ncol=2)

#The function call will infer the missing dimension automatically
matrix(1:10, nrow=5)

# Or you recombine them by adding a dimension to a vector
v <- c(1:10)
dim(v) <- c(2,5)
v
```

They can be combined out of single vectors trough **column-wise or row-wise** binding.
* `cbind` to combine the vectors column-wise
* `rbind` to combine row-wise

```{r}
x <- 1:3
y <- 10:12
# Column wise
cbind(x,y)
# Row wise
rbind(x,y)
```


### Lists

They are a special type of vector that can cointain elements of different classes. They are a very important data type. 
Especially in combination with the various `apply()` functions, they are a powerful combination.

They can be directly created using the `list()` function, which takes an arbitrary number of arguments to concatinate.

```{r}
l <- list(1,2,3, 'a', 'b', 'c', TRUE, FALSE, TRUE)
l
```

If we want to create a `list` with a preset length to be filled e.g. by a function call we can specify this with 
the `vector('list', length=??)` command call.

```{r}
vector('list', length=3)
```


### Factors & Factor Levels

To represent categorial variables, we can use the `Factor` type in R. This can be unordered or ordered.
Once can think of a factor as an integer vector where each integer has a label. 

Using a labeled factor is better, as labels are self describing, instead of using dummy variables (e.g. 0|1)

```{r}
x <- factor(c('yes', 'no', 'yes', 'yes', 'no', 'no'))
x
```

The `factor()` call automatically creates the factor levels by identifying the number of unique elements associated.
Now we can apply more advanced summary descriptions to the data

```{r}
table(x)
# And use the unclass() command to identfy the underlying structure of the data
unclass(x)

```

Often factors will be automatically created when importing a dataset using e.g. `read.table()` command. 
As this will create factor levels that are ordered by ascending first letters, we might want to give them a more indicative 
structure manually. 

This can be done useing the `levels` attribute to the `factor()` call.

```{r}
x <- factor(c('yes', 'no', 'yes', 'no', 'no'))
x # Levels are now in alphabetical ordering

# We can reassign a new ordering of the factors by directly assigning a vector
levels(x) <- c('yes', 'no')
x

# Or take care of the ordering in the function call itself
x <- factor(c('yes', 'no', 'yes', 'yes'), levels = c('yes', 'no'))
x
```


### Missing Values /  NANs

Indicated by NA or NaN. 

* `is.na()` is used to test object if they are NAs
* `is.nan()` is used to test for NaN
* NA values have a clas, so therea are ineger NA, character NA, etc.
* A NaN value is also NA but the converse does not hold true

```{r}
# Create a vector with NA in it
x <- c(2,3, NA, 10, 3)

# Function returns a boolean vector
is.na(x)

# This can be used for indexing to select NAs out
x_clean <- x[!is.na(x)]
x_clean

# We can impute the missing data with an average measurement e.g.

x[is.na(x)] <- 10
x
```


### DataFrames

Used to store tabular data in R. They are represented as a special type of list where every element of the list has to have the same length. 
Each element of the list can be thought of as a column and the length of theach element of the list is the number of rows.

Unlike matrices, data frames can store different classes of objects in each column. Matices must have every elemt be the same class. 
Data fames have a special attribute called `row.names` which indicate information about each row of teh data frame. 

They are usually not created manually, but read into R using

* `read.table()`
* or `read.csv()`

However, data frames can also be created explicitly with the `data.frame()` function or they can be coerced from other types of objects, like lists. 

For some applications, especially in machine learning, which mostly relies on linear algebra and matrix algebra applications, we have to work with the data
inside a table as a matrix. To this end we can use the `data.matrix()` or the `as.matrix()` even though mostly you will need the result of the previous.

Lets's look at an example:
```{r}
# First we create a data frame manually
x <- data.frame(foo = 1:4, bar=c(T,T,F,F))
x

# With the attributes dimension
dim(x)
nrow(x)
ncol(x)
```

DataTables can be indexed trough positional attributes, just as matrices. And they can aditionally be indexed using the row & column names.

```{r}
x[1] # Extracts the first column
x[,1] # Extracts the complete first row

x$foo # Indexes the first column
x$bar # Indexes the second column
```

### Names

As R is a statistical programming language, it is layed out to work closely with procedures used in everyday statistical analysis. Therefore the use of 
**named variables** in handy and easily accessible. 

```{r}
x <- 1:3
names(x)

# We can just assign names as a string vector to the names attribute of the variable
names(x) <- c('New York', 'Washington DC', 'Los Angeles')
x
```

In the same way we can assign names to **list** objects, which is very usefull when indexing or applying summary functions on them. 

```{r}
x <- list('Los Angeles' = 1, 'Boston' = 2, 'New York City' = 3)
x
names(x)
```

**matrices** can have row and dim names

```{r}
m <- matrix(1:4, nrow=2, ncol=2)
dimnames(m) <- list(c('a', 'b'), c('c', 'd'))
m

# Or we can again assign them individually
rownames(m) <- c('new', 'old')
colnames(m) <- c('first', 'last')
m
```

NOTE: There is a difference in setting col & row names in matrices and dataFrames

Object   |   Set column names   | set row names
-----------------------------------------------
data frame |  names()  | row.names()
matrix | colnames()   | rownames()

> This is a blockquote
> I can continue it for as long as i wish, but i definatly have to close it at the end

