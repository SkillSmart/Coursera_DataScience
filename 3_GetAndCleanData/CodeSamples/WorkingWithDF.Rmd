---
title: "GettingAndCleaningData - Working with DF"
author: "Frank Fichtenmueller"
date: "30 October 2016"
output: html_document
---
#####Working on Dataframes

###Working with the dplyr package
The dplyr package offers a clean and simple language to work on dataframes. It is based on splitting the work containing the selecting, reordering, filtering, subsetting and summarising into function calls in the form of verbs. 
* filter()
* select()
* arange()

As an easy to use example we will be working trough all possible functions on the basis of the flights dataset.
To make the data present in a neater and more concise format, dplyr provides a unique datastructre the tbl_df
```{r, echo=FALSE}
if (!require(dplyr) == TRUE) {install.packages("dplyr");require(dplyr)}
if (!require(nycflights13) == TRUE){install.packages("nycflights13"); require(nycflights13)}
library(nycflights13)
data("flights")
flights <- tbl_df(flights)
```
Now we can use the View() function to get a clean and orderly presentation of the dataset, that is also easily rescalable. Something
that is especially convenient when working with large and complicated datasets.
```{r}
glimpse(flights)
# And of course use summary(flights) to extract the basic statistical measurements. 

summary(flights)
```
The Dataset is quite large, so we will need to subset it to help speed up our calculations later on and get a better understanding of what is actually going on. 

#### filter() / slice() for selecting a subset of rows

The filter() is used to subset the rows in a dataframe based on a combination of evaluation characteristics. 

```{r}
filter(flights, month ==1, day ==1)
```
This is equivalent to the more verbose code in R:
```{r}
flights[flights$month ==1 & flights$day == 1,]
```
filter() works similarly to subset() except that you can give it any nubmer of filtering conditions, which are joined together with & (not &&). All other boolean operations apply as well. 

```{r}
head(filter(flights, month > 6 & day == 7),2)

# Selecting on OR
head(filter(flights, month == 1 | month==2),4)

```
if you want to select rows by their position in the dataset, use the slice() function
```{r}
slice(flights, 1:29)
```

####Arrange rows with arrange()
similarly to filter(), but with the goal of reordering them. It takes a dataframe, and a set of column names. If more than one name is provided, each additional coumn will be used to break ties.

```{r}
arrange(flights, year, month, day, dep_time, dep_delay)
```
Ordering in descending order, can be applied to the individual variables one at a time. 
```{r}
arrange(flights, year, desc(month), day)
```


dplyr offers its


####select() for selecting rows from a dataframe
select offers possiblities to subset the dataframe based on the columns(attributes) contained. 
These can be adressed by both the names and their respective order. 
```{r}
#Using the name attribute
head(select(flights, contains("time")),2)

#Using the number rank
head(select(flights, 1:3),2)

#Subsetting and reordering
head(select(flights, 1,3,2,4),2)

#Dropping a row
head(select(flights,-5),2)

```
If you want to paste more complicated combinations, you can paste them as a list into the 
function as an argument using the one_of()

```{r}
vars <- c("year","month", "day", "dep_time", "dest", "air_time", "origin", "distance")
head(select(flights, one_of(vars)),2)
```

###Renaming variables

Working wit live datasets, you have to regulary rename the attribute columns to make it easier or more appropriate to adress them in the following analysis. This is easily achieved using two different ways in dplyr.

```{r}
# Renaming variables during the selection, with only a subset beeing selected
head(select(flights, year, month, arrival = arr_time),2)
```
If you want to keep the structure, but just rename a subset of the columns, you can use the rename() function
```{r}
head(rename(flights, scheduled = sched_arr),2)
# This function call keeps all other variables automatically

# You can easily use a prefix to rename multiple columns in a single call
head(select(flights, petal = starts_with('Petal')),2)

```
As this involves the function call to select, in order to be able to adress the column names directly, we have to 
specify the function to keep the rest.

We can achieve this using the everything() function, that is a call to all current variables
It returns the numbers of the variables as a list
```{r}
everything(flights)
head(select(flights, petal = starts_with("Petal"),everything()),2)
```


###filter() and slice() - for subsetting entries(rows) 

rename()

}
